<!DOCTYPE html>
<html lang="zh-cmn-hans">
<head>
	<meta charset="UTF-8">
	<title>init & new - 密斯想</title>

	
<link rel="shortcut icon" href="../../../static/images/favicon.ico" type="image/x-icon">
<link rel="icon" href="../../../static/images/favicon.ico}" type="image/x-icon">
<link href="../../../static/css/blog.css" rel="stylesheet">
<link href="../../../static/lib/fontello.css" rel="stylesheet">
<link href="../../../static/lib/pygments/default.css" rel="stylesheet">
<style>
    .header-subtitle {
        font-style: normal;
    }
    .header-subtitle a {
        color: #eee;
        text-decoration: underline;
    }
    .header-subtitle a:hover {
        color: #fff;
        background: none;
    }
</style>

</head>
<body>
	<div id="header">
		<div class="header-container">
			<div class="header-nav">
				<div class="header-logo">
					<a href="/" class="float-left">
						密斯想 个人博客
					</a>
				</div>
				<div class="nav float-right">
					<a href="/">首页</a>
					<a href="/categories">分类</a>
					<a href="/tags">标签</a>
					<a href="/page/about">关于</a>
				</div>
			</div>

			<div class="header-wrapper">
				<div class="header-content">
					<h1 class="header-title">
						
init & new

					</h1>
					
<p class="header-date">
    <span class="post-time">
        <i class="demo-icon icon-calendar"></i> 发表于2018-03-28
    </span>
    <span class="post-category">
        <i class="demo-icon icon-folder-empty"></i> 分类：
        <a href="/category/随笔">随笔</a>
    </span>
</p>

					<div class="underline"></div>
					<p class="header-subtitle">
						


<a href="/tag/测试"><i class="demo-icon icon-tags"></i> 测试</a>

<a href="/tag/随笔"><i class="demo-icon icon-tags"></i> 随笔</a>



					</p>
				</div>
			</div>
		</div>
	</div>

	<div id="main">
		<div class="main-container">
			
<h5>1. self 和 cls</h5>
<p>首先来简要介绍一下类中的self和cls，如下栗：  </p>
<p>```python
class A(object):
   def foo1(self):
      print("Hello", self)</p>
<p>@classmethod
   def foo2(cls):
      print("Hello", cls)
  ```
调用foo1:</p>
<div class="highlight"><pre>&gt;&gt;&gt;a = A()
&gt;&gt;&gt;a.foo1()
Hello &lt;__main__.A object at 0x1040263c8&gt;
&gt;&gt;&gt;print(a)
Hello &lt;__main__.A object at 0x1040263c8&gt;
</pre></div>


<p>可以发现self和实例a指向了同一个对象，再调用类方法foo2：</p>
<div class="highlight"><pre>&gt;&gt;&gt;A.foo2()
Hello &lt;class &#39;__main__.A&#39;&gt;
</pre></div>


<p>发现此时指向的就是A类本身，从这个栗子我们可以得出，self指向了实例化对象而cls指向了类本身。</p>
<h5>2. <code>__init__</code>和<code>__new__</code></h5>
<p>我们再来看一下<code>__init__</code>，相信大家对<code>__init__</code>已经很熟悉了，<code>__init__</code>通常用于初始化一个类实例，如下例：  </p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>


<p>由于它是初始化一个类实例的，所有需要传入self。  </p>
<p>那么<code>__new__</code>方法又是做什么用的呢？看下面的栗子：  </p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;__init__ has been called&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;__new__ has been called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;A : x is {}, y is {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__y</span><span class="p">)</span>
</pre></div>


<p>这里有个小插曲，当我尝试实例化A类，并将其传入参数x,y时，报了以下错误：  </p>
<div class="highlight"><pre>&gt;&gt;&gt;tt=A(&#39;xxx&#39;,&#39;yyy&#39;)

in __new__
    return super(A, cls).__new__(cls, *args, **kwargs)
TypeError: object() takes no parameters
</pre></div>


<p>仔细阅读报的错，发现是由于<code>__new__</code>返回的是<strong>父类实例化后的对象的—<code>__new__</code>方法</strong>，而父类<strong>object</strong>的<code>__new__</code>方法不接受任何参数，可我却对其传了参。解决方法就是不对<strong>父类实例化的对象的<code>__new__</code>方法</strong>传参，将上述<code>__new__</code>方法改成如下： </p>
<div class="highlight"><pre>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;__new__ has been called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
</pre></div>


<p>再次运行</p>
<div class="highlight"><pre>&gt;&gt;&gt;tt=A(&#39;xxx&#39;,&#39;yyy&#39;)
&gt;&gt;&gt;print(tt)

__new__ has been called
__init__ has been called
A : x is xxx, y is yyy
</pre></div>


<p>一切都平静了，可以看到，当实例化对象时，先是调用了<code>__new__</code>，然后才调用了<code>__init__</code>进行了初始化。其中<code>__new__</code>方法中可以return父类<code>__new__</code>出来的实例，也可以直接将其他类<code>__new__</code>出来的实例返回（但这就意义不大了）。  <br />
那可不可以调用自身的<code>__new__</code>来制造实例呢？当然不行，因为这会造成死循环（一定要避免<code>return cls.__new__(cls)</code>)。  </p>
<p>新式类(最终继承到object)开始实例化时，<code>__new__</code>会返回一个实例，然后该类的<code>__init__</code>方法作为构造方法回接收这个实例(即self)作为自己的第一个参数，然后依次传入<code>__new__</code>方法中接收的其它参数。 </p>
<p>如果 <code>__new__</code>并未返回实例，那么当前类的<code>__init__</code>方法是不会被调用的。</p>
<h5>3. 使用<code>__new__</code>构造单例模式</h5>
<p>说了那么多，<code>__new__</code>方法到底有什么作用呢？接下来介绍一下如何使用它来创建单例模式。  </p>
<p>单例模式简单来说就是即一个类只有一个实例，看下面的栗子：  </p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">_a</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_a</span>

        <span class="k">return</span> <span class="n">ob</span>
</pre></div>


<p>实例化A，赋给a，并向_a添加新的键值对： </p>
<div class="highlight"><pre>&gt;&gt;&gt;a = A()
&gt;&gt;&gt;a._a[&#39;a&#39;] = 1
</pre></div>


<p>再次实例化A，赋给b，查看b的<code>__dict__</code>： </p>
<div class="highlight"><pre>&gt;&gt;&gt;b = A()
&gt;&gt;&gt;print(b.__dict__)
{&#39;a&#39;:1}
&gt;&gt;&gt;print(b.a)
1
</pre></div>


<p>居然有先前实例a的属性，而且居然还可以直接调用！
我们将实例b也赋予一些属性，并尝试通过实例a去调用：</p>
<div class="highlight"><pre>&gt;&gt;&gt;b.b=2
&gt;&gt;&gt;print(a.b)
2
</pre></div>


<p>仿佛实例a与实例b成了同一个实例，只是有了两个名字！这就实现了单例模式。<br />
我们来看一下上面的代码，<code>__dict__</code>是用来存储对象属性的一个字典，在A类中我们创建了一个空字典<code>_a</code>并将其传入<code>__dict__</code>，由于字典恰好是可变对象，所以当我们对任何A的实例添加属性进入<code>__dict__</code>时，<code>_a</code>也进行了更新，可以说<code>_a</code>中保存了最新的所有的A对象的属性键值对。将<code>_a</code>赋给实例的<code>__dict__</code>，每个实例也就拥有了同一个<code>__dict__</code>，真是神奇。  </p>
<p>于此类似的，利用<code>__new__</code>构建单例模式还有一种方法，如下栗：  </p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Singleton</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;_instance&#39;</span><span class="p">):</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Singleton</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_instance</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Singleton</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>


<p>具体的实现原理就不做赘述啦，相信读到这里你一定可以理解～</p>

		</div>
	</div>

	<div id="footer">
		<div class="footer-container">
			<p>
				©2018 <a href="#">cxx</a>
			</p>
			<p>
				<a href="#">备案号:无</a>
			</p>
			<p id="js-running">
			</p>
		</div>
	</div>

	<script>
	var startTime="2018-02-01";var calculationTime=function(startTime){var s1=new Date(startTime.replace(/-/g,"/")),s2=new Date(),runTime=parseInt((s2.getTime()-s1.getTime())/1000);var year=Math.floor(runTime/86400/365);runTime=runTime%(86400*365);var month=Math.floor(runTime/86400/30);runTime=runTime%(86400*30);var day=Math.floor(runTime/86400);runTime=runTime%86400;var hour=Math.floor(runTime/3600);runTime=runTime%3600;var minute=Math.floor(runTime/60);runTime=runTime%60;var second=runTime;document.querySelector(".runningTime > .year").innerText=year;document.querySelector(".runningTime > .month").innerText=month;document.querySelector(".runningTime > .day").innerText=day;document.querySelector(".runningTime > .hour").innerText=hour;document.querySelector(".runningTime > .minute").innerText=minute;document.querySelector(".runningTime > .second").innerText=second};setInterval("calculationTime(startTime)",1000);var node = document.createElement("span");node.innerHTML = '该站点运行了<label class="year">0</label>年<label class="month">0</label>月<label class="day">0</label>日<label class="hour">0</label>时<label class="minute">0</label>分<label class="second">0</label>秒';node.className = "runningTime";document.getElementById("js-running").appendChild(node);
	</script>
</body>
</html>