<!DOCTYPE html>
<html lang="zh-cmn-hans">
<head>
	<meta charset="UTF-8">
	<title>Hello python - 密斯想</title>

	
<link rel="shortcut icon" href="../../../static/images/favicon.ico" type="image/x-icon">
<link rel="icon" href="../../../static/images/favicon.ico}" type="image/x-icon">
<link href="../../../static/css/blog.css" rel="stylesheet">
<link href="../../../static/lib/fontello.css" rel="stylesheet">
<link href="../../../static/lib/pygments/default.css" rel="stylesheet">
<style>
    .header-subtitle {
        font-style: normal;
    }
    .header-subtitle a {
        color: #eee;
        text-decoration: underline;
    }
    .header-subtitle a:hover {
        color: #fff;
        background: none;
    }
</style>

</head>
<body>
	<div id="header">
		<div class="header-container">
			<div class="header-nav">
				<div class="header-logo">
					<a href="/" class="float-left">
						密斯想 个人博客
					</a>
				</div>
				<div class="nav float-right">
					<a href="/">首页</a>
					<a href="/categories">分类</a>
					<a href="/tags">标签</a>
					<a href="/page/about">关于</a>
				</div>
			</div>

			<div class="header-wrapper">
				<div class="header-content">
					<h1 class="header-title">
						
Hello python

					</h1>
					
<p class="header-date">
    <span class="post-time">
        <i class="demo-icon icon-calendar"></i> 发表于2018-03-28
    </span>
    <span class="post-category">
        <i class="demo-icon icon-folder-empty"></i> 分类：
        <a href="/category/随笔">随笔</a>
    </span>
</p>

					<div class="underline"></div>
					<p class="header-subtitle">
						


<a href="/tag/测试"><i class="demo-icon icon-tags"></i> 测试</a>

<a href="/tag/随笔"><i class="demo-icon icon-tags"></i> 随笔</a>



					</p>
				</div>
			</div>
		</div>
	</div>

	<div id="main">
		<div class="main-container">
			
<h2>Hello python</h2>
<h2>1. Python函数参数</h2>
<h4>1. 位置参数</h4>
<p>调用时根据定义参数的顺序传参，如下例：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span>
<span class="n">fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>      <span class="c"># 结果为 1-2 = -1</span>
</pre></div>


<h4>2. 默认参数</h4>
<p>定义函数时写入默认参数，即便不传参也不会显示错误，如下例：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">function</span> <span class="p">(</span><span class="n">param</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">param</span>
</pre></div>


<p>规范： 将默认的、变化不大的写在后面，变化大的参数写在前面</p>
<h4>3. 可更改与不可更改参数</h4>
<p>所有的变量都可以理解是内存中一个对象的“引用”，而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象，看下例：</p>
<div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">print</span> <span class="n">a</span>     <span class="c"># 结果为1，不会随函数调用而更改</span>
</pre></div>


<div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="n">a</span>     <span class="c"># 结果为[1]，随函数调用而更改</span>
</pre></div>


<h4>4. 可变参数</h4>
<p>可变参数在函数调用时自动组装成tuple，直接上栗子：  </p>
<p>定义：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">pass</span> 
</pre></div>


<p>调用方法一：</p>
<div class="highlight"><pre><span class="n">fun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>调用方法二：</p>
<div class="highlight"><pre><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
</pre></div>


<h4>5. 关键字参数</h4>
<p>关键字参数在函数调用时自动组装成dict, 可不传，也可传入任意个数的关键字参数（必须传入参数名），上栗子：  </p>
<p>定义：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">kw</span> 
</pre></div>


<p>调用方法一：</p>
<div class="highlight"><pre><span class="n">fun</span><span class="p">(</span><span class="n">city</span> <span class="o">=</span> <span class="s">&#39;Beijing&#39;</span><span class="p">)</span>  <span class="c"># 返回{&#39;city&#39;:&#39;Beijing&#39;}</span>
</pre></div>


<p>调用方法二：</p>
<div class="highlight"><pre><span class="n">fun</span><span class="p">(</span><span class="n">gender</span> <span class="o">=</span><span class="s">&#39;M&#39;</span><span class="p">,</span> <span class="n">job</span> <span class="o">=</span> <span class="s">&#39;Coder&#39;</span><span class="p">)</span>  <span class="c"># 返回{&#39;gender&#39;:&#39;M&#39;, &#39;job&#39;:&#39;Coder&#39;}</span>
</pre></div>


<p>备注：当传入一个dict时，函数内部对其修改不会影响函数外的dict</p>
<h4>6. 命名关键字参数</h4>
<p>限制了传入的关键字参数，只接受固定名称参数传入，如下：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">paraA</span><span class="p">,</span> <span class="n">paraB</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keyParaA</span><span class="p">,</span> <span class="n">keyParaB</span><span class="p">)</span><span class="err">：</span>
    <span class="k">pass</span>
</pre></div>


<p>则只有key为keyParaA和keyParaB的关键字函数可以传入。</p>
<h4>7. <code>*args</code> and <code>**kwargs</code></h4>
<p>当不确定函数里将要传递多少参数时你可以用<code>*args</code>，相似的，<code>**kwargs</code>允许使用没有事先定义的参数名；<br />
你也可以混着使用，命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>，命名参数在列表的最前端，如： </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">table_things</span><span class="p">(</span><span class="n">titlestring</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>


<p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中，但是<code>*args</code>必须在<code>**kwargs</code>前面。</p>
<h2>2. Python方法</h2>
<p>Python有三种方法，分别是实例方法，静态方法(staticmethod)以及类方法(classmethod)，结合下例说明一下这三种方法的区别：</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;executing fun(</span><span class="si">%s</span><span class="s">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;executing fun(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_fun</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;executing class_fun(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;executing static_fun(</span><span class="si">%s</span><span class="s">)&quot;</span><span class="o">%</span><span class="n">x</span>

<span class="n">a</span><span class="o">=</span><span class="n">A</span><span class="p">()</span>
</pre></div>


<p>接下来我们来结合栗子对这三种方法做一下讲解。<br />
对于实例方法，在类里每次定义方法的时候都需要绑定一个实例，在上栗中，fun()就是实例方法，它的调用离不开实例，所以我们把实例自己(self) 作为参数传给方法，便能进行方法与实例的绑定； <br />
显然易见，class_fun()就是类方法了，而它则是通过cls来绑定了类；  <br />
而静态方法则不需要对谁进行绑定，那么这三种方法在调用时有什么区别呢？ </p>
<table>
<thead>
<tr>
<th align="left">\</th>
<th align="left">实例方法</th>
<th align="left">类方法</th>
<th align="left">静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">a = A()</td>
<td align="left">a.fun(x)</td>
<td align="left">a.class_fun(x)</td>
<td align="left">a.static_fun(x)</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">不可用</td>
<td align="left">A.class_fun(x)</td>
<td align="left">A.static_fun(x)</td>
</tr>
</tbody>
</table>
<h2>3. Python中的下划线</h2>
<p>废话不说直接上栗子：  </p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>             <span class="bp">self</span><span class="o">.</span><span class="n">__superprivate</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="o">...</span>             <span class="bp">self</span><span class="o">.</span><span class="n">_semiprivate</span> <span class="o">=</span> <span class="s">&quot;, world!&quot;</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">mc</span><span class="o">.</span><span class="n">__superprivate</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">AttributeError</span><span class="p">:</span> <span class="n">myClass</span> <span class="n">instance</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s">&#39;__superprivate&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">mc</span><span class="o">.</span><span class="n">_semiprivate</span>
<span class="p">,</span> <span class="n">world</span><span class="err">!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">mc</span><span class="o">.</span><span class="n">__dict__</span>
<span class="p">{</span><span class="s">&#39;_MyClass__superprivate&#39;</span><span class="p">:</span> <span class="s">&#39;Hello&#39;</span><span class="p">,</span> <span class="s">&#39;_semiprivate&#39;</span><span class="p">:</span> <span class="s">&#39;, world!&#39;</span><span class="p">}</span>
</pre></div>


<p><code>__foo__</code>:只是约定,Python内部的名字，用来区别其他用户自定义的命名，以防冲突。</p>
<p><code>_foo</code>:只是约定，用来指定变量私有.程序员用来指定私有变量的一种方式；</p>
<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字，以区别和其他类相同的命名。</p>
<h2>4. Python装饰器</h2>
<h4>1. 两点定义：</h4>
<ul>
<li>前有@，将之后出现的函数作为参数传入</li>
<li>返回作为参数传入的函数</li>
</ul>
<h4>2、 栗子</h4>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">log</span> <span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span>       
    <span class="k">def</span> <span class="nf">wrapper</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span> <span class="p">(</span> <span class="err">‘</span><span class="n">call</span> <span class="o">%</span><span class="n">s</span><span class="err">’</span> <span class="o">%</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@log</span>
<span class="k">def</span> <span class="nf">now</span> <span class="p">(</span> <span class="p">):</span>
    <span class="k">print</span> <span class="p">(</span><span class="err">‘</span><span class="mi">2017</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">09</span><span class="err">’</span><span class="p">)</span>
</pre></div>


<h4>3. 说明</h4>
<p>在上栗中，调用now()时，now()方法会作为参数传入log()方法，实际上是调用了以now()为参数的log()方法；<br />
上栗的打印内容是： </p>
<div class="highlight"><pre>call now ( ):
2017-05-09
</pre></div>


<p>这么解释或许更加专业，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数log(now)，返回wrapper()函数。  </p>
<h2>5. Lambda</h2>
<p>Lambda又称匿名函数，当我们需要使用一个简单的且无需重复调用的函数时，就可以使用lambda，优雅又简洁。其使用方法如下例：  </p>
<div class="highlight"><pre>lambda 参数 : 返回值
</pre></div>


<p>是不是超简单，那看一下具体使用吧： </p>
<div class="highlight"><pre>map( lambda x: x*x, [y for y in range(10)] )
</pre></div>


<p>上述代码等价于：  </p>
<div class="highlight"><pre>def sq(x):
    return x * x

map(sq, [y for y in range(10)])
</pre></div>


<p>使用lambda可以有效减少代码量，这样的写法是将「遍历列表，给遇到的每个元素都做某种运算」的过程从一个循环里抽象出来成为一个函数 map，然后用 lambda 表达式将这种运算作为参数传给 map。Python 之中，类似能用到 lambda 表达式的「高级」函数还有sort,reduce,filter等等。 </p>
<h2>6. <code>map()</code>,<code>reduce()</code>,<code>filter()</code></h2>
<p>既然说到了lambda，那就不得不提map()、reduce()和filter()，下面就一一介绍一下吧： </p>
<h4>1. <code>map()</code></h4>
<p>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。<br />
比如我们有一个函数f(x)=x*x，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<div class="highlight"><pre><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
</pre></div>


<p>map()传入的第一个参数是f，即需要对列表中的元素进行的操作，第二个参数是迭代列表，返回则是一个新的经过处理后的列表。
map()作为高阶函数，将运算规则抽象了，将列表中的数字转为字符串只需要一行代码：  </p>
<div class="highlight"><pre><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
</pre></div>


<h4>2. <code>reduce()</code></h4>
<p>与map()相同，reduce()同样接收两个参数，第一个是函数（这个函数必须接收两个参数），第二个是迭代列表，它的效果如下：  </p>
<div class="highlight"><pre><span class="nb">reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">])</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">x3</span><span class="p">),</span> <span class="n">x4</span><span class="p">)</span>
</pre></div>


<p>即列表中的第一个元素与第二个元素作为参数传入f()的返回值，与列表中的第三个元素再次作为参数传入f()......</p>
<h4>3. <code>filter()</code></h4>
<p>filter()函数用于过滤序列。<br />
又和map()类似的是，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素，上栗子：  </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

<span class="nb">filter</span><span class="p">(</span><span class="n">is_odd</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="c"># 结果: [1, 5, 9, 15]</span>
</pre></div>


<h2>7. Python中的拷贝</h2>
<p>上个栗子一目了然： </p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">copy</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]]</span>  <span class="c">#原始对象</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>  <span class="c">#赋值，传对象的引用</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c">#对象拷贝，浅拷贝</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c">#对象拷贝，深拷贝</span>

<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c">#修改对象a</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">)</span>  <span class="c">#修改对象a中的[&#39;a&#39;, &#39;b&#39;]数组对象</span>

<span class="k">print</span> <span class="s">&#39;a = &#39;</span><span class="p">,</span> <span class="n">a</span>
<span class="k">print</span> <span class="s">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span>
<span class="k">print</span> <span class="s">&#39;c = &#39;</span><span class="p">,</span> <span class="n">c</span>
<span class="k">print</span> <span class="s">&#39;d = &#39;</span><span class="p">,</span> <span class="n">d</span>

<span class="err">输出结果：</span>
<span class="n">a</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">],</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]]</span>
<span class="n">d</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]]</span>
</pre></div>


<h2>8. Python中的正则表达式</h2>
<h4>1.预设元字符</h4>
<ul>
<li><code>\w</code> 匹配任意一个单词字符，包括数字和下划线，等价于[A-Za-z0-9_]，例如 a\wc 可以匹配 abc、acc</li>
<li><code>\W</code> 匹配任意一个非单词字符，与 \w 操作相反，它等价于 [^A-Za-z0-9_]，例如： a\Wc 可匹配 a!c</li>
<li><code>\s</code> 匹配任意一个空白字符，空格、回车等都是空白字符，例如：a\sc 可以配 a\nc，这里的 \n表示回车</li>
<li><code>\S</code> 匹配任意一个非空白字符</li>
<li><code>\d</code> 匹配任意一个数字，它等价于[0-9]，例如：a\dc 可匹配 a1c、a2c ...</li>
<li><code>\D</code> 匹配任意一个非数字</li>
</ul>
<h4>2.基本元字符</h4>
<ul>
<li><code>.</code> 匹配除换行符以外的任意一个字符，例如："a.c" 可以完全匹配 "abc"，也可以匹配 "abcef" 中的 "abc"</li>
<li><code>\</code> 转义字符，使特殊字符具有本来的意义，例如： 1.2 可以匹配 1.2</li>
<li><code>[...]</code> 匹配方括号中的任意一个字符，例如：a[bcd]e 可以匹配 abe、ace、ade，它还支持范围操作，比如：a到z可表示为 "a-z"，0到9可表示为 "0-9"，注意，在 "[]" 中的特殊字符不再有特殊意义，就是它字面的意义，例如：[.*]就是匹配 . 或者 *</li>
<li><code>[^...]</code> 字符集取反，表示只要不是括号中出现的字符都可以匹配，例如：a[^bcd]e 可匹配 aee、afe等</li>
</ul>
<h4>3.重复匹配</h4>
<ul>
<li><code>*</code> 重复匹配零次或者更多次</li>
<li><code>?</code> 重复匹配零次或者一次</li>
<li><code>+</code> 重复匹配1次或者多次</li>
<li><code>{n}</code> 重复匹配n次</li>
<li><code>{n,}</code> 重复匹配至少n次</li>
<li><code>{n, m}</code> 重复匹配n到m次</li>
</ul>
<h4>4.贪婪与非贪婪</h4>
<ul>
<li><code>贪婪模式</code> 正则表达式重复匹配时，在使整个表达式能得到匹配的前提下尽可能匹配多的字符，我们称之为贪婪模式；<br />
  例如： r"a.*b" 表示匹配 a 开头 b 结尾，中间可以是任意多个字符的字符串，如果用它来匹配 aaabcb，那么它会匹配整个字符串</li>
<li><code>非贪婪模式</code> 只需要在量词后面加一个问号" ？"，在保证匹配的情况下尽可能少的匹配;<br />
  比如刚才的例子，我们只希望匹配 aaab，那么只需要修改正则表达式为 r"a.*?b"</li>
</ul>
<h4>5.正则引擎</h4>
<ul>
<li>
<p><code>re.match(pattern, string)</code> <br />
match方法从字符串的起始位置开始检查，如果刚好有一个子字符串与正则表达式相匹配，则返回一个Match对象，只要起始位置不匹配则退出，返回 None</p>
</li>
<li>
<p><code>re.search(pattern, string)</code><br />
search 方法虽然也是从起始位置开始检查，但是它在起始位置不匹配的时候会一直尝试往后检查，直到匹配为止，如果到字符串的末尾还没有匹配，则返回 None</p>
</li>
<li>
<p><code>re.findall(pattern, string)</code>
findall 返回的对象是由匹配的子字符串组成的列表，即使匹配到了也不中断，继续匹配</p>
</li>
</ul>
<p>写了那么多，但每次写正则的时候，我还是会用度娘 =.=</p>

		</div>
	</div>

	<div id="footer">
		<div class="footer-container">
			<p>
				©2018 <a href="#">cxx</a>
			</p>
			<p>
				<a href="#">备案号:无</a>
			</p>
			<p id="js-running">
			</p>
		</div>
	</div>

	<script>
	var startTime="2018-02-01";var calculationTime=function(startTime){var s1=new Date(startTime.replace(/-/g,"/")),s2=new Date(),runTime=parseInt((s2.getTime()-s1.getTime())/1000);var year=Math.floor(runTime/86400/365);runTime=runTime%(86400*365);var month=Math.floor(runTime/86400/30);runTime=runTime%(86400*30);var day=Math.floor(runTime/86400);runTime=runTime%86400;var hour=Math.floor(runTime/3600);runTime=runTime%3600;var minute=Math.floor(runTime/60);runTime=runTime%60;var second=runTime;document.querySelector(".runningTime > .year").innerText=year;document.querySelector(".runningTime > .month").innerText=month;document.querySelector(".runningTime > .day").innerText=day;document.querySelector(".runningTime > .hour").innerText=hour;document.querySelector(".runningTime > .minute").innerText=minute;document.querySelector(".runningTime > .second").innerText=second};setInterval("calculationTime(startTime)",1000);var node = document.createElement("span");node.innerHTML = '该站点运行了<label class="year">0</label>年<label class="month">0</label>月<label class="day">0</label>日<label class="hour">0</label>时<label class="minute">0</label>分<label class="second">0</label>秒';node.className = "runningTime";document.getElementById("js-running").appendChild(node);
	</script>
</body>
</html>